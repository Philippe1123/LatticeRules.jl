var documenterSearchIndex = {"docs":
[{"location":"#","page":"Home","title":"Home","text":"CurrentModule = LatticeRules","category":"page"},{"location":"#LatticeRules-1","page":"Home","title":"LatticeRules","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [LatticeRules]","category":"page"},{"location":"#LatticeRules.LatticeRule32-Tuple{AbstractString}","page":"Home","title":"LatticeRules.LatticeRule32","text":"LatticeRule32(file, s, n)\nLatticeRule32(file, s)\nLatticeRule32(file)\n\nReturns a rank-1 lattice rule in s dimensions with generating vector z read from the file file and with at most n points.\n\nExamples\n\njulia> z_file = K_3600_32_file;\n\njulia> lattice_rule = LatticeRule32(z_file, 16)\nLatticeRule32{16}\n\njulia> getpoint(lattice_rule, 123)\n16-element Array{Float64,1}:\n 0.8671875\n 0.9609375\n 0.6015625\n 0.8984375\n 0.6484375\n 0.6328125\n 0.3203125\n 0.2890625\n 0.0234375\n 0.1015625\n 0.7890625\n 0.0703125\n 0.6953125\n 0.0234375\n 0.1171875\n 0.0859375\n\n\nSee also: getpoint, ShiftedLatticeRule32\n\n\n\n\n\n","category":"method"},{"location":"#LatticeRules.LatticeRule32-Tuple{Array{UInt32,1}}","page":"Home","title":"LatticeRules.LatticeRule32","text":"LatticeRule32(z, s, n)\nLatticeRule32(z, s)\nLatticeRule32(z)\n\nReturns a rank-1 lattice rule in s dimensions with generating vector z and at most n points.\n\nWhen no maximum number of points n is provided, we assume n = typemax(UInt32) = 2^32 - 1. When no number of dimensions s is provided, we assume s = length(z). \n\ninfo: Info\nTechnically, we return an extensible lattice sequence where the k-th point is transformed using the gray coded radical inverse function. This has the advantage that we can add points to the lattice without changing the already computed points.\n\nMore generating vectors can be found online here or here.\n\nExamples\n\njulia> lattice_rule = LatticeRule32([UInt32(1), UInt32(5)], 2, 8) # Fibonacci lattice\nLatticeRule32{2}\n\njulia> getpoint(lattice_rule, 2)\n2-element Array{Float64,1}:\n 0.25\n 0.25\n\n\nSee also: getpoint, ShiftedLatticeRule32\n\n\n\n\n\n","category":"method"},{"location":"#LatticeRules.LatticeRule32-Tuple{Integer}","page":"Home","title":"LatticeRules.LatticeRule32","text":"LatticeRule32(s)\n\nReturns a rank-1 lattice rule in s dimensions that uses a default generating vector with order-2 weights.\n\nExamples\n\njulia> lattice_rule = LatticeRule32(16)\nLatticeRule32{16}\n\njulia> getpoint(lattice_rule, 123)\n16-element Array{Float64,1}:\n 0.8671875\n 0.5390625\n 0.6015625\n 0.3671875\n 0.6796875\n 0.8203125\n 0.3046875\n 0.8515625\n 0.7109375\n 0.6328125\n 0.5703125\n 0.2578125\n 0.6953125\n 0.0390625\n 0.2421875\n 0.4453125\n\n\nSee also: getpoint, ShiftedLatticeRule32\n\n\n\n\n\n","category":"method"},{"location":"#LatticeRules.ShiftedLatticeRule32-Tuple{Integer}","page":"Home","title":"LatticeRules.ShiftedLatticeRule32","text":"ShiftedLatticeRule32(s)\n\nReturns a shifted rank-1 lattice rule in s dimensions that uses a default generating vector with order-2 weights and a randomly generated shift vector.\n\nExamples\n\njulia> shifted_lattice_rule = ShiftedLatticeRule32(16)\nShiftedLatticeRule32{16}\n\njulia> shifted_lattice_rule[0]\n16-element Array{Float64,1}:\n 0.23603334566204692\n 0.34651701419196046\n 0.3127069683360675\n 0.00790928339056074\n 0.4886128300795012\n 0.21096820215853596\n 0.951916339835734\n 0.9999046588986136\n 0.25166218303197185\n 0.9866663668987996\n 0.5557510873245723\n 0.43710797460962514\n 0.42471785049513144\n 0.773223048457377\n 0.2811902322857298\n 0.20947237319807077\n\n\nSee also: getpoint, ShiftedLatticeRule32\n\n\n\n\n\n","category":"method"},{"location":"#LatticeRules.ShiftedLatticeRule32-Union{Tuple{LatticeRule32{s}}, Tuple{s}} where s","page":"Home","title":"LatticeRules.ShiftedLatticeRule32","text":"ShiftedLatticeRule32(lattice_rule)\nShiftedLatticeRule32(lattice_rule, shift)\n\nReturns a shifted rank-1 lattice rule based on the lattice rule lattice_rule using the random shift shift. If no random shift is provided, we use shift = rand(length(lattice_rule)).\n\nExamples\n\njulia> lattice_rule = LatticeRule32(16)\nLatticeRule32{16}\n\njulia> shifted_lattice_rule = ShiftedLatticeRule32(lattice_rule)\nShiftedLatticeRule32{16}\n\njulia> getpoint(shifted_lattice_rule, 0)\n16-element Array{Float64,1}:\n 0.23603334566204692\n 0.34651701419196046\n 0.3127069683360675\n 0.00790928339056074\n 0.4886128300795012\n 0.21096820215853596\n 0.951916339835734\n 0.9999046588986136\n 0.25166218303197185\n 0.9866663668987996\n 0.5557510873245723\n 0.43710797460962514\n 0.42471785049513144\n 0.773223048457377\n 0.2811902322857298\n 0.20947237319807077\n\n\nSee also: LatticeRule32, getpoint\n\n\n\n\n\n","category":"method"},{"location":"#LatticeRules.getpoint-Tuple{AbstractLatticeRule,Number}","page":"Home","title":"LatticeRules.getpoint","text":"getpoint(lattice_rule, k)\n\nGet the k-th point of the lattice rule lattice_rule.\n\nnote: Note\nAn alternative syntax is getindex(lattice_rule, k) or lattice_rule[k], this allows you to write the one-liner Q = mean(f.(lattice_rule[0:N-1])) for the quasi-Monte Carlo estimator for Ef.\n\njulia> lattice_rule = LatticeRule32(2)\nLatticeRule32{2}\n\njulia> getpoint(lattice_rule, 3)\n2-element Array{Float64,1}:\n 0.75\n 0.25\n\n\nSee also: LatticeRule32, ShiftedLatticeRule32\n\n\n\n\n\n","category":"method"}]
}
